<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      body {
        font-family: Arial, Helvetica, sans-serif;
      }
      * {
        box-sizing: border-box;
      }
      #canvas {
        background-color: #f5f5f5;
        box-sizing: content-box;
        border: 2px solid #000;
        position: absolute;
        margin: 0 auto;
        top: 50%;
        left: 0;
        right: 0;
        transform: translateY(-50%);
      }
      #canvas .cell {
        background-color: #fff;
        border: 2px solid #000;
        position: absolute;
      }
      #canvas .cell.endpoint {
        background-color: rgb(0, 162, 255);
        z-index: 2;
      }
      #canvas .cell.obstacle {
        background-color: #333;
        z-index: 2;
      }
      #canvas .cell.path {
        background-color: rgb(0, 255, 98);
        z-index: 2;
      }
      #canvas .cell > i {
        position: absolute;
        top: 4px;
        font-size: 0.8em;
        font-style: normal;
      }
      #canvas .cell > i.g {
        left: 4px;
      }
      #canvas .cell > i.h {
        right: 4px;
      }
      #canvas .cell > i.f {
        right: 3px;
        left: 3px;
        font-size: 1.5em;
        line-height: 2.65em;
        text-align: center;
      }
      #canvas .cell.path.current {
        background-color: rgb(148, 0, 0);
      }
    </style>
  </head>
  <body>
    <div id="canvas"></div>
    <button onclick="solve()">Solve</button>
    <script>
      function cellNode() {
        this.el = null;
        this.x = null;
        this.y = null;
        this.gCost = null;
        this.hCost = null;
        this.fCost = null;
      }
      let grid = document.getElementById("canvas");
      let gridX = 10;
      let gridY = 10;
      let cellSize = 70;

      let nodesList = [];
      let nodesMap = {};
      let obstacleMap = {};
      let endPoints = { x: 8, y: 4 };
      let startPoints = { x: 1, y: 1 };

      // Create endpoints
      let startNode = createNode(1, 1, "endpoint", '<i class="f">A</i>');
      let endNode = createNode(8, 4, "endpoint", '<i class="f">B</i>');

      function createNode(x, y, className, data) {
        let node = document.createElement("div");
        node.className = "cell";
        node.style.left = `${x * cellSize}px`;
        node.style.top = `${y * cellSize}px`;
        node.style.width = `${cellSize}px`;
        node.style.height = `${cellSize}px`;
        if (className) {
          node.className += ` ${className}`;
        }
        if (data) {
          node.innerHTML = data;
        }
        grid.appendChild(node);
        return node;
      }

      // Generate the grid
      function generateGrid() {
        grid.style.width = `${gridX * cellSize}px`;
        grid.style.height = `${gridY * cellSize}px`;
        for (let x = 0; x < gridX; x++) {
          for (let y = 0; y < gridY; y++) {
            let nodeEl = createNode(x, y);
            let node = new cellNode();
            node.x = x;
            node.y = y;
            node.el = nodeEl;
            nodesList.push(nodeEl);
            nodesMap[`${x}:${y}`] = node;
          }
        }
      }
      generateGrid();
      console.log(nodesList);
      console.log(nodesMap);

      // Create obstacles
      obstacleMap[7] = {};
      obstacleMap[8] = {};
      obstacleMap[7][3] = createNode(7, 3, "obstacle");
      obstacleMap[7][4] = createNode(7, 4, "obstacle");
      obstacleMap[8][3] = createNode(8, 3, "obstacle");

      function solve() {
        // get surrounding paths
        let currentNode = nodesMap[1][1];
        let surroundingNodes = getSurroundingNodes(currentNode);

        let loops = 0;
        while (
          currentNode.coords.x != endPoints.x &&
          currentNode.coords.y != endPoints.y &&
          loops < 20
        ) {
          console.log("loop count: ", loops);
          loops += 1;
        }

        // Get lowest fCost
        let lowestFCost = 99999;
        for (let i = 0; i < surroundingNodes.length; i++) {
          if (surroundingNodes[i].fCost < lowestFCost) {
            lowestFCost = surroundingNodes[i].fCost;
          }
        }

        // queue lowest fCosts
        for (let i = 0; i < surroundingNodes.length; i++) {
          if (surroundingNodes[i].fCost === lowestFCost) {
            openNodes.push(surroundingNodes[i]);
            openNodesMap[surroundingNodes[i].coords.x] = !!openNodesMap[
              surroundingNodes[i].coords.x
            ]
              ? openNodesMap[surroundingNodes[i].coords.x]
              : {};
            openNodesMap[surroundingNodes[i].coords.x][
              surroundingNodes[i].coords.y
            ] = surroundingNodes[i];

            console.log(openNodes);
            console.log(openNodesMap);
          }
        }
      }

      function getSurroundingNodes(node) {
        let coords = node.coords;
        let surroundingNodes = [];
        if (isValidCoords({ x: coords.x, y: coords.y - 1 })) {
          let node = nodesMap[coords.x][coords.y - 1];
          node.parentNode = nodesMap[coords.x][coords.y];
          surroundingNodes.push(node);
        }
        if (isValidCoords({ x: coords.x - 1, y: coords.y })) {
          let node = nodesMap[coords.x - 1][coords.y];
          node.parentNode = nodesMap[coords.x][coords.y];
          surroundingNodes.push(node);
        }
        if (isValidCoords({ x: coords.x + 1, y: coords.y })) {
          let node = nodesMap[coords.x + 1][coords.y];
          node.parentNode = nodesMap[coords.x][coords.y];
          surroundingNodes.push(node);
        }
        if (isValidCoords({ x: coords.x, y: coords.y + 1 })) {
          let node = nodesMap[coords.x][coords.y + 1];
          node.parentNode = nodesMap[coords.x][coords.y];
          surroundingNodes.push(node);
        }

        for (let i = 0; i < surroundingNodes.length; i++) {
          let gCost = getDistance(surroundingNodes[i].coords, startPoints);
          let hCost = getDistance(surroundingNodes[i].coords, endPoints);
          let fCost = gCost + hCost;
          let node = surroundingNodes[i].el;
          surroundingNodes[i].gCost = gCost;
          surroundingNodes[i].hCost = hCost;
          surroundingNodes[i].fCost = fCost;
          node.innerHTML = `<i class="g">${gCost}</i><i class="h">${hCost}</i><i class="f">${fCost}</i>`;
          node.classList.add("path");
        }
        return surroundingNodes;
      }

      function createAdjacentNode(x, y) {
        // Check if coords is valid
        // Compute gCost hCost fCost
        // Update node at this point only if fCost is lower
      }

      function isValidCoords(coords) {
        if (
          coords.x > -1 &&
          coords.x < cellSize / gridX &&
          coords.y > -1 &&
          coords.y < cellSize / gridY &&
          !(obstacleMap[coords.x] && obstacleMap[coords.x][coords.y]) &&
          !(coords.x == endPoints.x && coords.y == endPoints.y) &&
          !(coords.x == startPoints.x && coords.y == startPoints.y)
        ) {
          return true;
        }
        return false;
      }

      function getDistance(originCoords, targetCoords) {
        return (
          (Math.abs(originCoords.x - targetCoords.x) +
            Math.abs(originCoords.y - targetCoords.y)) *
          10
        );
      }
    </script>
  </body>
</html>
